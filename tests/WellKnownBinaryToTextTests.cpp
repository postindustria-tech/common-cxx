/* *********************************************************************
 * This Original Work is copyright of 51 Degrees Mobile Experts Limited.
 * Copyright 2025 51 Degrees Mobile Experts Limited, Davidson House,
 * Forbury Square, Reading, Berkshire, United Kingdom RG1 3EU.
 *
 * This Original Work is licensed under the European Union Public Licence (EUPL)
 * v.1.2 and is subject to its terms as set out below.
 *
 * If a copy of the EUPL was not distributed with this file, You can obtain
 * one at https://opensource.org/licenses/EUPL-1.2.
 *
 * The 'Compatible Licences' set out in the Appendix to the EUPL (as may be
 * amended by the European Commission) shall be deemed incompatible for
 * the purposes of the Work and the provisions of the compatibility
 * clause in Article 5 of the EUPL shall not apply.
 *
 * If using the Work as, or as part of, a network application, by
 * including the attribution notice(s) required under Article 5 of the EUPL
 * in the end user terms of the application under an appropriate heading,
 * such notice(s) shall fulfill the requirements of that article.
 * ********************************************************************* */

#include "pch.h"
#include "../string.h"
#include "../wkbtot.h"

static bool CheckResult(const char *result, const char *expected, size_t const size) {
	bool match = true;
	for (size_t i = 0; i < size; i++) {
		match = match && (*result == *expected);
		result++;
		expected++;
	}
	return match;
}

static size_t constexpr DEFAULT_BUFFER_SIZE = 1024;

static void convertAndCompare_base(
	const byte * const wkbBytes,
	const char * const expected,
	const char * const comment,
	int8_t const decimalPlaces,
	int const statusCode) {

	char buffer[DEFAULT_BUFFER_SIZE] = { 0 };
	FIFTYONE_DEGREES_EXCEPTION_CREATE;

	auto const result = fiftyoneDegreesConvertWkbToWkt(
		wkbBytes,
		buffer, std::size(buffer),
		decimalPlaces,
		exception);

	if (statusCode < 0) {
		EXPECT_TRUE(FIFTYONE_DEGREES_EXCEPTION_OKAY) <<
			"Got exception while converting WKB: " << fiftyoneDegreesExceptionGetMessage(exception);
	} else {
		EXPECT_TRUE(FIFTYONE_DEGREES_EXCEPTION_CHECK(statusCode)) <<
			"Got wrong exception while converting WKB: " << fiftyoneDegreesExceptionGetMessage(exception)
			<< " -- expected: "
			<< fiftyoneDegreesStatusGetMessage(static_cast<fiftyoneDegreesStatusCode>(statusCode), nullptr)
			<< std::endl;
	}

	EXPECT_FALSE(result.bufferTooSmall) <<
		"Buffer was deemed too small, requested " << result.written <<
		", available " <<  std::size(buffer) << std::endl;

	EXPECT_TRUE(
		CheckResult(buffer, expected, strlen(expected))) <<
		"The value of " << comment << " is not correctly converted:\n -- '" << buffer <<
		"'\nvs expected\n -- '" << expected << "'" << std::endl;
}

static void convertAndCompare_withDecimalPlaces(
	const byte * const wkbBytes,
	const char * const expected,
	const char * const comment,
	int8_t const decimalPlaces) {

	convertAndCompare_base(
		wkbBytes,
		expected,
		comment,
		decimalPlaces,
		-1);  // no exception expected
}

static void convertAndCompare(
	const byte * const wkbBytes,
	const char * const expected,
	const char * const comment) {

	convertAndCompare_withDecimalPlaces(
		wkbBytes,
		expected,
		comment,
		15); // max precision
}

static void convertAndCompare_withExceptionStatus(
	const byte * const wkbBytes,
	const char * const expected,
	const char * const comment,
	fiftyoneDegreesStatusCode const statusCode) {

	convertAndCompare_base(
		wkbBytes,
		expected,
		comment,
		-17, // max precision, 'g'-format
		statusCode);
}

TEST(WKBToT, WKBToT_Test_Point_2D_NDR)
{
	const byte wkbBytes[] = {
		0x00, // big endian
      	0x00,0x00,0x00,0x01, // POINT (2D)
        0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 2.0: x-coordinate
      	0x40,0x10,0x00,0x00,0x00,0x00,0x00,0x00, // 4.0: y-coordinate
    };
	const char * const expected = "POINT(2 4)";

	convertAndCompare(wkbBytes, expected, "Point 2D (NDR)");
}

TEST(WKBToT, WKBToT_Test_Point_2D_XDR)
{
	const byte wkbBytes[] = {
		0x01,
		0x01, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x31, 0x40,
	};
	const char * const expected = "POINT(3.5 17.25)";

	convertAndCompare(wkbBytes, expected, "Point 2D (XDR)");
}

TEST(WKBToT, WKBToT_Test_Point_2D_3places)
{
	const byte wkbBytes[] = {
		0x00,
		0x00, 0x00, 0x00, 0x01,
		0x40, 0x31, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
      	0x40, 0x8b, 0xe0, 0xc0, 0x00, 0x00, 0x00, 0x00,
	};
	const char * const expected = "POINT(17.25 892.094)";

	convertAndCompare_withDecimalPlaces(wkbBytes, expected, "Point 2D (3 decimal places)", 3);
}

TEST(WKBToT, WKBToT_Test_LineStringZ_XDR)
{
	const byte wkbBytes[] = {
		0x01,
		0xea, 0x03, 0x00, 0x00,
		0x04, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x26, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x4f, 0x40,
		0x00, 0x00, 0x00, 0x00, 0xc0, 0xe0, 0x8b, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x30, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0xcf, 0x67, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x23, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x71, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x37, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x07, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd4, 0x3f,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
	};
	const char * const expected = "LINESTRING Z("
	"2 11.125 63.0625,"
	"892.09375 16.28125 190.46875,"
	"9.59375 273.8125 23.15625,"
	"2.9375 0.3125 1)";

	convertAndCompare(wkbBytes, expected, "LineString Z (XDR)");
}

TEST(WKBToT, WKBToT_Test_PolygonM_XDR)
{
	const byte wkbBytes[] = {
		0x01,
		0xd3, 0x07, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, // 2 rings
		0x04, 0x00, 0x00, 0x00, // 4 points
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0xc0,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x4f, 0xc0,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0xc0,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0xc0,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0xc0,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x4f, 0x40,
		0x03, 0x00, 0x00, 0x00, // 3 points
		0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x8b, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x67, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x71, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
	};
	const char * const expected = "POLYGON M((2 -11 -63,-7 3 -5,6 -9 17,-2 11 63),(892 16 190,9 273 23,2 0 1))";

	convertAndCompare(wkbBytes, expected, "Polygon M (XDR)");
}

TEST(WKBToT, WKBToT_Test_TriangleZM_XDR)
{
	const byte wkbBytes[] = {
		0x01,
		0xc9, 0x0b, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, // 2 rings
		0x03, 0x00, 0x00, 0x00, // 3 points
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xbf,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xbf,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x40,
		0x03, 0x00, 0x00, 0x00, // 3 points
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0xc0,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0xc0,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0xc0,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0xc0,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x40,
	};
	const char * const expected = "TRIANGLE ZM((-1 -1 1 1,2 -2 2 2,-2 2 3 3),(-10 -10 10 10,20 -20 20 20,-20 20 30 30))";

	convertAndCompare(wkbBytes, expected, "Triangle ZM (XDR)");
}

TEST(WKBToT, WKBToT_Standard_Point2D_Simple)
{
	const byte wkbBytes[] = {
		0x01,
		0x01, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
	};
	const char * const expected = "POINT(10 10)";

	convertAndCompare(wkbBytes, expected, "Point 2D");
}

TEST(WKBToT, WKBToT_Standard_LineString)
{
	const byte wkbBytes[] = {
		0x01,
		0x02, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, // 3 points
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x40,
	};
	const char * const expected = "LINESTRING(10 10,20 20,30 40)";

	convertAndCompare(wkbBytes, expected, "LineString");
}

TEST(WKBToT, WKBToT_Standard_Polygon)
{
	const byte wkbBytes[] = {
		0x01,
		0x03, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00, // 1 rings
		0x05, 0x00, 0x00, 0x00, // 5 points
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
	};
	const char * const expected = "POLYGON"
	"((10 10,10 20,20 20,20 15,10 10))";

	convertAndCompare(wkbBytes, expected, "Polygon");
}

TEST(WKBToT, WKBToT_Standard_MultiPoint)
{
	const byte wkbBytes[] = {
		0x01,
		0x04, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, // 2 points
		0x01,
		0x01, 0x00, 0x00, 0x00, // point
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x01,
		0x01, 0x00, 0x00, 0x00, // point
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x40,
	};
	const char * const expected = "MULTIPOINT((10 10),(20 20))";

	convertAndCompare(wkbBytes, expected, "MultiPoint");
}

TEST(WKBToT, WKBToT_Standard_MultiLineString)
{
	const byte wkbBytes[] = {
		0x01,
		0x05, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, // 2 lines
		0x01,
		0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, // 2 points
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x40,
		0x01,
		0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, // 2 points
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x40,
	};
	const char * const expected = "MULTILINESTRING"
	"("
	"(10 10,20 20),(15 15,30 15)"
	")";

	convertAndCompare(wkbBytes, expected, "MultiLineString");
}

TEST(WKBToT, WKBToT_Standard_MultiPolygon)
{
	const byte wkbBytes[] = {
		0x01,
		0x06, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, // 2 polygons
		0x01,
		0x03, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00, // 1 ring
		0x05, 0x00, 0x00, 0x00, // 5 points
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x01,
		0x03, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00, // 1 ring
		0x04, 0x00, 0x00, 0x00, // 4 points
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x51, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x51, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0x40,
	};
	const char * const expected = "MULTIPOLYGON"
	"("
	"((10 10,10 20,20 20,20 15,10 10)),"
	"((60 60,70 70,80 60,60 60))"
	")";

	convertAndCompare(wkbBytes, expected, "MultiPolygon");
}

TEST(WKBToT, WKBToT_Standard_GeometryCollection)
{
	const byte wkbBytes[] = {
		0x01,
		0x07, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, // 3 geometries
		0x01,
		0x01, 0x00, 0x00, 0x00, // point
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x01,
		0x01, 0x00, 0x00, 0x00, // point
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x40,
		0x01,
		0x02, 0x00, 0x00, 0x00, // line string
		0x02, 0x00, 0x00, 0x00, // 2 points
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x40,
	};
	const char * const expected = "GEOMETRYCOLLECTION"
	"("
	"POINT(10 10),"
	"POINT(30 30),"
	"LINESTRING(15 15,20 20)"
	")";

	convertAndCompare(wkbBytes, expected, "GeometryCollection");
}

TEST(WKBToT, WKBToT_Standard_PolyhedronZ)
{
    const byte wkbBytes[] = {
        0x01,
        0xf7, 0x03, 0x00, 0x00,
        0x06, 0x00, 0x00, 0x00, // 6 polygons
        0x01,
        0xeb, 0x03, 0x00, 0x00, // polygon z
    	0x01, 0x00, 0x00, 0x00, // 1 ring
        0x05, 0x00, 0x00, 0x00, // 5 points
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x01,
        0xeb, 0x03, 0x00, 0x00, // polygon z
		0x01, 0x00, 0x00, 0x00, // 1 ring
		0x05, 0x00, 0x00, 0x00, // 5 points
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x01,
        0xeb, 0x03, 0x00, 0x00, // polygon z
		0x01, 0x00, 0x00, 0x00, // 1 ring
		0x05, 0x00, 0x00, 0x00, // 5 points
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    	0x01,
        0xeb, 0x03, 0x00, 0x00, // polygon z
		0x01, 0x00, 0x00, 0x00, // 1 ring
		0x05, 0x00, 0x00, 0x00, // 5 points
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    	0x01,
        0xeb, 0x03, 0x00, 0x00, // polygon z
		0x01, 0x00, 0x00, 0x00, // 1 ring
		0x05, 0x00, 0x00, 0x00, // 5 points
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    	0x01,
        0xeb, 0x03, 0x00, 0x00, // polygon z
		0x01, 0x00, 0x00, 0x00, // 1 ring
		0x05, 0x00, 0x00, 0x00, // 5 points
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
    };
	const char * const expected = "POLYHEDRALSURFACE Z"
	"("
	"((0 0 0,0 0 1,0 1 1,0 1 0,0 0 0)),"
	"((0 0 0,0 1 0,1 1 0,1 0 0,0 0 0)),"
	"((0 0 0,1 0 0,1 0 1,0 0 1,0 0 0)),"
	"((1 1 0,1 1 1,1 0 1,1 0 0,1 1 0)),"
	"((0 1 0,0 1 1,1 1 1,1 1 0,0 1 0)),"
	"((0 0 1,1 0 1,1 1 1,0 1 1,0 0 1))"
	")";

	convertAndCompare(wkbBytes, expected, "PolyhedralSurface Z");
}

TEST(WKBToT, WKBToT_Standard_TinZ)
{
    const byte wkbBytes[] = {
        0x01,
        0xf8, 0x03, 0x00, 0x00,
        0x04, 0x00, 0x00, 0x00, // 4 polygons
    	0x01,
        0xeb, 0x03, 0x00, 0x00, // polygon z
		0x01, 0x00, 0x00, 0x00, // 1 ring
        0x04, 0x00, 0x00, 0x00, // 4 points
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    	0x01,
        0xeb, 0x03, 0x00, 0x00, // polygon z
		0x01, 0x00, 0x00, 0x00, // 1 ring
		0x04, 0x00, 0x00, 0x00, // 4 points
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    	0x01,
        0xeb, 0x03, 0x00, 0x00, // polygon z
		0x01, 0x00, 0x00, 0x00, // 1 ring
		0x04, 0x00, 0x00, 0x00, // 4 points
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    	0x01,
        0xeb, 0x03, 0x00, 0x00, // polygon z
		0x01, 0x00, 0x00, 0x00, // 1 ring
		0x04, 0x00, 0x00, 0x00, // 4 points
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    };
	const char * const expected = "TIN Z("
	"((0 0 0,0 0 1,0 1 0,0 0 0)),"
	"((0 0 0,0 1 0,1 0 0,0 0 0)),"
	"((0 0 0,1 0 0,0 0 1,0 0 0)),"
	"((1 0 0,0 1 0,0 0 1,1 0 0))"
	")";

	convertAndCompare(wkbBytes, expected, "Tin Z");
}

TEST(WKBToT, WKBToT_Standard_PointZ)
{
	const byte wkbBytes[] = {
		0x01,
		0xe9, 0x03, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x40,
	};
	const char * const expected = "POINT Z(10 10 5)";

	convertAndCompare(wkbBytes, expected, "Point Z");
}

TEST(WKBToT, WKBToT_Standard_PointZM)
{
	const byte wkbBytes[] = {
		0x01,
		0xb9, 0x0b, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x40,
	};
	const char * const expected = "POINT ZM(10 10 5 40)";

	convertAndCompare(wkbBytes, expected, "Point ZM");
}

TEST(WKBToT, WKBToT_Standard_PointM)
{
	const byte wkbBytes[] = {
		0x01,
		0xd1, 0x07, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x40,
	};
	const char * const expected = "POINT M(10 10 40)";

	convertAndCompare(wkbBytes, expected, "Point M");
}

TEST(WKBToT, WKBToT_SampleWKB_OpenLayers)
{
	// https://openlayers.org/en/latest/examples/wkb.html
	const byte wkbBytes[] = {
		0x01,
		0x03,0x00,0x00,0x00,
		0x01,0x00,0x00,0x00, // 1 ring
		0x05,0x00,0x00,0x00, // 5 points
		0x54,0xE3,0xA5,0x9B,0xC4,0x60,0x25,0x40,
		0x64,0x3B,0xDF,0x4F,0x8D,0x17,0x39,0xC0,
		0x5C,0x8F,0xC2,0xF5,0x28,0x4C,0x41,0x40,
		0xEC,0x51,0xB8,0x1E,0x85,0x2B,0x34,0xC0,
		0xD5,0x78,0xE9,0x26,0x31,0x68,0x43,0x40,
		0x6F,0x12,0x83,0xC0,0xCA,0xD1,0x41,0xC0,
		0x1B,0x2F,0xDD,0x24,0x06,0x01,0x2B,0x40,
		0xA4,0x70,0x3D,0x0A,0xD7,0x93,0x43,0xC0,
		0x54,0xE3,0xA5,0x9B,0xC4,0x60,0x25,0x40,
		0x64,0x3B,0xDF,0x4F,0x8D,0x17,0x39,0xC0,
	};
	const char * const expected = "POLYGON((10.689 -25.091999999999999,34.594999999999999 -20.170000000000002,38.814 -35.639000000000003,13.502000000000001 -39.155000000000001,10.689 -25.091999999999999))";

	convertAndCompare(wkbBytes, expected, "SampleWKB from OpenLayers");
}

TEST(WKBToT, WKBToT_SampleWKB_GitHub)
{
	// https://openlayers.org/en/latest/examples/wkb.html
	const byte wkbBytes[] = {
		0x00,
		0x00, 0x00, 0x00, 0x06,
		0x00, 0x00, 0x00, 0x02, // 2 polygons
		0x00,
		0x00, 0x00, 0x00, 0x03, // polygon
		0x00, 0x00, 0x00, 0x01, // 1 ring
		0x00, 0x00, 0x00, 0x04, // 4 points
		0x40, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x40, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x40, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x40, 0x46, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x40, 0x46, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x40, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x40, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x40, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00,
		0x00, 0x00, 0x00, 0x03, // polygon
		0x00, 0x00, 0x00, 0x02, // 2 rings
		0x00, 0x00, 0x00, 0x06, // 6 points
		0x40, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x40, 0x41, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x40, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x40, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x40, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x40, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x40, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x40, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x40, 0x46, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x40, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x40, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x40, 0x41, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x04, // 4 points
		0x40, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x40, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x40, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x40, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x40, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x40, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x40, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x40, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	};
	const char * const expected = "MULTIPOLYGON(((40 40,20 45,45 30,40 40)),((20 35,10 30,10 10,30 5,45 20,20 35),(30 20,20 15,20 25,30 20)))";

	convertAndCompare(wkbBytes, expected, "SampleWKB from OpenLayers");
}

TEST(WKBToT, WKBToT_SampleWKB_OsGeo_Collection)
{
	// https://www.osgeo.cn/app/s1343#google_vignette
	const byte wkbBytes[] = {
		0x01,
		0x07, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, // 2 geometries
		0x01,
		0x01, 0x00, 0x00, 0x00, // point
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x40,
		0x01,
		0x02, 0x00, 0x00, 0x00, // line string
		0x02, 0x00, 0x00, 0x00, // 2 points
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
	};
	const char * const expected = "GEOMETRYCOLLECTION(POINT(4 6),LINESTRING(4 6,7 10))";

	convertAndCompare(wkbBytes, expected, "GeometryCollection from osgeo.cn");
}

TEST(WKBToT, WKBToT_SampleWKB_OsGeo_MultiLineString)
{
	// https://www.osgeo.cn/app/s1343#google_vignette
	const byte wkbBytes[] = {
		0x01,
		0x05, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, // 2 line strings
		0x01,
		0x02, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, // 3 points
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x40,
		0x01,
		0x02, 0x00, 0x00, 0x00,
		0x04, 0x00, 0x00, 0x00, // 4 points
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
	};
	const char * const expected = "MULTILINESTRING((10 10,20 20,10 40),(40 40,30 30,40 20,30 10))";

	convertAndCompare(wkbBytes, expected, "MultiLineString from osgeo.cn");
}

TEST(WKBToT, WKBToT_SampleWKB_OsGeo_MultiPolygon)
{
	// https://www.osgeo.cn/app/s1343#google_vignette
	const byte wkbBytes[] = {
		0x01,
		0x06, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, // 2 polygons
		0x01,
		0x03, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00, // 1 ring
		0x04, 0x00, 0x00, 0x00, // 4 points
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x46, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x40,
		0x01,
		0x03, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00, // 1 rings
		0x05, 0x00, 0x00, 0x00, // 5 points
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x40,
	};
	const char * const expected = "MULTIPOLYGON(((30 20,45 40,10 40,30 20)),((15 5,40 10,10 20,5 10,15 5)))";

	convertAndCompare(wkbBytes, expected, "MultiPolygon from osgeo.cn");
}

TEST(WKBToT, WKBToT_Exception_UnknownGeometryRoot)
{
	const byte wkbBytes[] = {
		0x01,
		0xd3, 0x00, 0x00, 0x00, // garbage?
		// exception expected here, the rest does not matter
	};
	const char * const expected = "";

	convertAndCompare_withExceptionStatus(
		wkbBytes,
		expected,
		"Unknown Geometry (Root)",
		FIFTYONE_DEGREES_STATUS_INVALID_INPUT);
}

TEST(WKBToT, WKBToT_Test_LineStringZ_UnknownGeometryEmbedded)
{
	const byte wkbBytes[] = {
		0x01,
		0x04, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, // 3 points
		0x01,
		0x01, 0x00, 0x00, 0x00, // point
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x01,
		0x09, 0x00, 0x00, 0x00, // CompoundCurve
		// exception expected here, the rest does not matter
		0x01,
		0x01, 0x00, 0x00, 0x00, // point
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x40,
	};
	const char * const expected = "MULTIPOINT((10 10),";

	convertAndCompare_withExceptionStatus(
		wkbBytes,
		expected,
		"Unknown Geometry (Embedded)",
		FIFTYONE_DEGREES_STATUS_INVALID_INPUT);
}

TEST(WKBToT, WKBToT_String_Point_2D_NDR)
{
	constexpr byte wkbStringBytes[] = {
		20,00, // length of WKB 'trail' of #String

		0x00, // big endian
		0x00,0x00,0x00,0x01, // POINT (2D)
		0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 2.0: x-coordinate
		0x40,0x10,0x00,0x00,0x00,0x00,0x00,0x00, // 4.0: y-coordinate
	};
	const char * const expected = "POINT(2 4)";

	const byte * const wkbBytes = &wkbStringBytes[2];
	convertAndCompare(wkbBytes, expected, "Point 2D (NDR) from String");
}
